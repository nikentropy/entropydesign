<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KD3VSJQ"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.7/dist/gsap.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.7/dist/CustomEase.min.js"></script>



<script>
/* Edge correct breakpoint on mobile L and refresh on device rotation */
const isEdge = navigator.userAgent.match(/Edg/i);

function handleEdgeLandscape() {
    if (isEdge && window.innerWidth > 767 && window.innerHeight < 500) {
        const viewportMeta = document.querySelector('meta[name="viewport"]');
        viewportMeta.content = 'width=767, user-scalable=no';
        document.body.classList.add('edge-mobile-landscape');
    }
}

// Only run Edge-specific logic
if (isEdge) {
    // Initial adjustment
    handleEdgeLandscape();

    // Edge-only orientation change handler
    let orientationTimeout;
    window.addEventListener('orientationchange', () => {
        clearTimeout(orientationTimeout);
        orientationTimeout = setTimeout(() => {
            location.reload();
        }, 150);
    });

    // Optional: Add visual feedback for Edge users only
    document.addEventListener('DOMContentLoaded', () => {
        const loader = document.createElement('div');
        loader.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            display: none;
        `;
        document.body.appendChild(loader);

        window.addEventListener('orientationchange', () => {
            loader.style.display = 'block';
        });
    });
}
</script>





<style>
/* Prevent form autofill highlight */
  input:-webkit-autofill,
  input:-webkit-autofill:hover,
  input:-webkit-autofill:focus,
  textarea:-webkit-autofill,
  textarea:-webkit-autofill:hover,
  textarea:-webkit-autofill:focus {
    -webkit-text-fill-color: white !important; /* Keep text white */
    transition: background-color 9999s ease-in-out !important; /* Prevent autofill highlight */
    background-color: transparent !important; /* Remove background highlight */
    caret-color: white !important; /* Ensures cursor stays visible */
  }
</style>




<script>
/* Custom dropdown arrow */
document.addEventListener("DOMContentLoaded", function () {
  const selectFields = document.querySelectorAll(".form-text-field.enquiry-type-field");

  function updateSelectAppearance(selectField) {
    // Update main select element styling
    if (selectField.selectedIndex > 0) {
      selectField.style.color = "#FFFFFF";
      selectField.style.backgroundImage = "url('https://cdn.prod.website-files.com/5c0f9d0dc4055a028374139d/67e52e940336b6f5ba7f89f8_Dropdown%20Arrow%20White.svg')";
    } else {
      selectField.style.color = "#C7C7C7";
      selectField.style.backgroundImage = "url('https://cdn.prod.website-files.com/5c0f9d0dc4055a028374139d/67e52e90b13914f1969cb416_Dropdown%20Arrow%20c7c7c7.svg')";
    }
  }

  selectFields.forEach(function(selectField) {
    selectField.addEventListener("change", function() {
      updateSelectAppearance(selectField);
    });
    // Initialize on page load
    updateSelectAppearance(selectField);
  });
});
</script>








<script>
/* Add name to form success text */
$(document).ready(function() {
  let submittedNames = {
    default: null,
    modal: null
  };

  function updateSuccessMessage(formType = 'default') {
    const suffix = formType === 'modal' ? '-modal' : '';
    const successMessage = $(`#form-success-text${suffix}`);
    const name = submittedNames[formType];
    
    if (!name) return;

    let successText = `THANK YOU FOR YOUR ENQUIRY, ${name}.`;

    // Apply the same conditional logic regardless of device
    const $tempSpan = $('<span>').text(successText).css({
      position: 'absolute',
      visibility: 'hidden',
      whiteSpace: 'nowrap',
      fontSize: successMessage.css('font-size'),
      fontFamily: successMessage.css('font-family')
    }).appendTo('body');
    
    if ($tempSpan.width() > $(window).width() * 0.2) {
      successText = `THANK YOU FOR YOUR ENQUIRY,<br>${name}.`;
    }
    $tempSpan.remove();
    
    successMessage.html(successText);
  }

  // Handle both form types
  $("form").on("submit", function(event) {
    event.preventDefault();
    const $form = $(this);
    const isModalForm = $form.find('#name-input-modal').length > 0;
    const formType = isModalForm ? 'modal' : 'default';
    const nameInputId = isModalForm ? '#name-input-modal' : '#name-input';

    submittedNames[formType] = $(nameInputId).val();

    $.ajax({
      type: "POST",
      url: this.action,
      data: $(this).serialize(),
      error: error => console.log("Form submission failed:", error)
    });

    updateSuccessMessage(formType);
  });

  // Update all messages on resize
  $(window).on("resize", function() {
    updateSuccessMessage('default');
    updateSuccessMessage('modal');
  });
  
  // Add orientation change listener
  $(window).on("orientationchange", function() {
    setTimeout(function() {
      updateSuccessMessage('default');
      updateSuccessMessage('modal');
    }, 200);
  });
});
</script>





<script>
let scrollPosition = 0;
let originalViewportContent = document.getElementById('viewport-meta').content;

// This is our main function to prevent zooming while the modal is open
function handleModalZoomPrevention() {
  // Target all inputs in the modal
  const formInputs = document.querySelectorAll('.form-modal-container input, .form-modal-container textarea, .form-modal-container select');
  
  // For each input, we'll add specific focus and blur handlers
  formInputs.forEach(input => {
    // When an input gets focus (clicked/tapped)
    input.addEventListener('focus', function() {
      // Only for iOS which is the problematic platform
      if (/(iPhone|iPad|iPod)/i.test(navigator.userAgent)) {
        // Force the viewport to stay at 1.0 scale
        document.getElementById('viewport-meta').content = 
          'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
          
        // Scroll to the input - this helps prevent iOS from trying to zoom
        setTimeout(() => {
          // Calculate position relative to viewport
          const rect = this.getBoundingClientRect();
          // Scroll the element into middle of view
          window.scrollTo(0, window.scrollY + rect.top - (window.innerHeight / 2));
        }, 50);
      }
    });
    
    // When focus leaves the input
    input.addEventListener('blur', function() {
      if (/(iPhone|iPad|iPod)/i.test(navigator.userAgent)) {
        // Keep preventing zoom
        document.getElementById('viewport-meta').content = 
          'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
      }
    });
  });
}

// Clean event handler for touch events
function preventMultitouchZoom(e) {
  // Only prevent if multiple touches (pinch) or control key
  if ((e.touches && e.touches.length > 1) || e.ctrlKey) {
    e.preventDefault();
  }
}

// Lock the viewport and prevent zooming when the modal is open
function lockViewport() {
  // Save scroll position
  scrollPosition = window.scrollY;
  
  // Lock the body
  document.body.style.position = 'fixed';
  document.body.style.top = `-${scrollPosition}px`;
  document.body.style.width = '100%';
  
  // Mark document as modal-open
  document.documentElement.classList.add('modal-open');
  
  // Change viewport to prevent zooming
  document.getElementById('viewport-meta').content = 
    'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
  
  // Add event listeners to prevent multi-touch zoom
  document.addEventListener('touchstart', preventMultitouchZoom, { passive: false });
  document.addEventListener('touchmove', preventMultitouchZoom, { passive: false });
  
  // Set up our input-specific handling
  handleModalZoomPrevention();
}

// Unlock the viewport and restore normal behavior when modal is closed
function unlockViewport() {
  // Restore body positioning
  document.body.style.position = '';
  document.body.style.top = '';
  document.body.style.width = '';
  
  // Remove modal-open class
  document.documentElement.classList.remove('modal-open');
  
  // Restore original viewport
  document.getElementById('viewport-meta').content = originalViewportContent;
  
  // Restore scroll position
  window.scrollTo(0, scrollPosition);
  
  // Remove event listeners
  document.removeEventListener('touchstart', preventMultitouchZoom);
  document.removeEventListener('touchmove', preventMultitouchZoom);
}

// Open Modal
function openModal() {
  document.body.classList.add('modal-open');
  lockViewport();
}

// Close Modal
function closeModal() {
  document.body.classList.remove('modal-open');
  unlockViewport();
}

// Webflow Integration
document.addEventListener('DOMContentLoaded', () => {
  // Modal opener buttons
  document.querySelectorAll('.nav-link.enquire').forEach(btn => {
    btn.addEventListener('click', openModal);
  });

// Modal close buttons
document.querySelectorAll('.main-title-div.form-title-div.enquire-button-div.form-close-div, .body-text-white-link').forEach(btn => {
  btn.addEventListener('click', closeModal);
});

// Submit button with 11-second delay
document.querySelectorAll('.coloured-button.delay-form-close-button').forEach(btn => {
  btn.addEventListener('click', function() {
    // Close modal after 11 seconds
    setTimeout(closeModal, 11000);
  });
});
</script>


<script>
/* Enquire Modal overscroll prevention */
function preventBounce(event) {
  // Get the element
  const modal = document.querySelector('.form-modal-container');
  
  // If we're at the top and trying to scroll up, prevent default
  if (modal.scrollTop <= 0 && event.touches[0].screenY > event.touches[1].screenY) {
    event.preventDefault();
  }
  
  // If we're at the bottom and trying to scroll down, prevent default
  if ((modal.scrollTop + modal.clientHeight) >= modal.scrollHeight && 
      event.touches[0].screenY < event.touches[1].screenY) {
    event.preventDefault();
  }
}

// Then in your lockViewport function, add:
function lockViewport() {
  // ... existing code ...
  
  // Add this line to handle bounce prevention
  document.querySelector('.form-modal-container').addEventListener('touchmove', preventBounce, { passive: false });
}

// And in unlockViewport, remove the listener:
function unlockViewport() {
  // ... existing code ...
  
  // Add this line
  document.querySelector('.form-modal-container').removeEventListener('touchmove', preventBounce);
}
</script>
